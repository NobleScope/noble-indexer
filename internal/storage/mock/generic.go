// Code generated by MockGen. DO NOT EDIT.
// Source: generic.go
//
// Generated by this command:
//
//	mockgen -source=generic.go -destination=mock/generic.go -package=mock -typed
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	storage "github.com/baking-bad/noble-indexer/internal/storage"
	types "github.com/baking-bad/noble-indexer/pkg/types"
	storage0 "github.com/dipdup-net/indexer-sdk/pkg/storage"
	pq "github.com/lib/pq"
	bun "github.com/uptrace/bun"
	gomock "go.uber.org/mock/gomock"
)

// MockTransaction is a mock of Transaction interface.
type MockTransaction struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionMockRecorder
	isgomock struct{}
}

// MockTransactionMockRecorder is the mock recorder for MockTransaction.
type MockTransactionMockRecorder struct {
	mock *MockTransaction
}

// NewMockTransaction creates a new mock instance.
func NewMockTransaction(ctrl *gomock.Controller) *MockTransaction {
	mock := &MockTransaction{ctrl: ctrl}
	mock.recorder = &MockTransactionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransaction) EXPECT() *MockTransactionMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockTransaction) Add(ctx context.Context, model any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", ctx, model)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockTransactionMockRecorder) Add(ctx, model any) *MockTransactionAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockTransaction)(nil).Add), ctx, model)
	return &MockTransactionAddCall{Call: call}
}

// MockTransactionAddCall wrap *gomock.Call
type MockTransactionAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionAddCall) Return(arg0 error) *MockTransactionAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionAddCall) Do(f func(context.Context, any) error) *MockTransactionAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionAddCall) DoAndReturn(f func(context.Context, any) error) *MockTransactionAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BulkSave mocks base method.
func (m *MockTransaction) BulkSave(ctx context.Context, models []any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BulkSave", ctx, models)
	ret0, _ := ret[0].(error)
	return ret0
}

// BulkSave indicates an expected call of BulkSave.
func (mr *MockTransactionMockRecorder) BulkSave(ctx, models any) *MockTransactionBulkSaveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BulkSave", reflect.TypeOf((*MockTransaction)(nil).BulkSave), ctx, models)
	return &MockTransactionBulkSaveCall{Call: call}
}

// MockTransactionBulkSaveCall wrap *gomock.Call
type MockTransactionBulkSaveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionBulkSaveCall) Return(arg0 error) *MockTransactionBulkSaveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionBulkSaveCall) Do(f func(context.Context, []any) error) *MockTransactionBulkSaveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionBulkSaveCall) DoAndReturn(f func(context.Context, []any) error) *MockTransactionBulkSaveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockTransaction) Close(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockTransactionMockRecorder) Close(ctx any) *MockTransactionCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockTransaction)(nil).Close), ctx)
	return &MockTransactionCloseCall{Call: call}
}

// MockTransactionCloseCall wrap *gomock.Call
type MockTransactionCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionCloseCall) Return(arg0 error) *MockTransactionCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionCloseCall) Do(f func(context.Context) error) *MockTransactionCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionCloseCall) DoAndReturn(f func(context.Context) error) *MockTransactionCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CopyFrom mocks base method.
func (m *MockTransaction) CopyFrom(ctx context.Context, tableName string, data []storage0.Copiable) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyFrom", ctx, tableName, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyFrom indicates an expected call of CopyFrom.
func (mr *MockTransactionMockRecorder) CopyFrom(ctx, tableName, data any) *MockTransactionCopyFromCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyFrom", reflect.TypeOf((*MockTransaction)(nil).CopyFrom), ctx, tableName, data)
	return &MockTransactionCopyFromCall{Call: call}
}

// MockTransactionCopyFromCall wrap *gomock.Call
type MockTransactionCopyFromCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionCopyFromCall) Return(arg0 error) *MockTransactionCopyFromCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionCopyFromCall) Do(f func(context.Context, string, []storage0.Copiable) error) *MockTransactionCopyFromCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionCopyFromCall) DoAndReturn(f func(context.Context, string, []storage0.Copiable) error) *MockTransactionCopyFromCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteBalances mocks base method.
func (m *MockTransaction) DeleteBalances(ctx context.Context, ids []uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteBalances", ctx, ids)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteBalances indicates an expected call of DeleteBalances.
func (mr *MockTransactionMockRecorder) DeleteBalances(ctx, ids any) *MockTransactionDeleteBalancesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteBalances", reflect.TypeOf((*MockTransaction)(nil).DeleteBalances), ctx, ids)
	return &MockTransactionDeleteBalancesCall{Call: call}
}

// MockTransactionDeleteBalancesCall wrap *gomock.Call
type MockTransactionDeleteBalancesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionDeleteBalancesCall) Return(arg0 error) *MockTransactionDeleteBalancesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionDeleteBalancesCall) Do(f func(context.Context, []uint64) error) *MockTransactionDeleteBalancesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionDeleteBalancesCall) DoAndReturn(f func(context.Context, []uint64) error) *MockTransactionDeleteBalancesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteTokenBalances mocks base method.
func (m *MockTransaction) DeleteTokenBalances(ctx context.Context, tokenIds []string, contractIds []uint64, zeroBalances []*storage.TokenBalance) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteTokenBalances", ctx, tokenIds, contractIds, zeroBalances)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteTokenBalances indicates an expected call of DeleteTokenBalances.
func (mr *MockTransactionMockRecorder) DeleteTokenBalances(ctx, tokenIds, contractIds, zeroBalances any) *MockTransactionDeleteTokenBalancesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTokenBalances", reflect.TypeOf((*MockTransaction)(nil).DeleteTokenBalances), ctx, tokenIds, contractIds, zeroBalances)
	return &MockTransactionDeleteTokenBalancesCall{Call: call}
}

// MockTransactionDeleteTokenBalancesCall wrap *gomock.Call
type MockTransactionDeleteTokenBalancesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionDeleteTokenBalancesCall) Return(arg0 error) *MockTransactionDeleteTokenBalancesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionDeleteTokenBalancesCall) Do(f func(context.Context, []string, []uint64, []*storage.TokenBalance) error) *MockTransactionDeleteTokenBalancesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionDeleteTokenBalancesCall) DoAndReturn(f func(context.Context, []string, []uint64, []*storage.TokenBalance) error) *MockTransactionDeleteTokenBalancesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exec mocks base method.
func (m *MockTransaction) Exec(ctx context.Context, query string, params ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, query}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockTransactionMockRecorder) Exec(ctx, query any, params ...any) *MockTransactionExecCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, query}, params...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockTransaction)(nil).Exec), varargs...)
	return &MockTransactionExecCall{Call: call}
}

// MockTransactionExecCall wrap *gomock.Call
type MockTransactionExecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionExecCall) Return(arg0 int64, arg1 error) *MockTransactionExecCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionExecCall) Do(f func(context.Context, string, ...any) (int64, error)) *MockTransactionExecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionExecCall) DoAndReturn(f func(context.Context, string, ...any) (int64, error)) *MockTransactionExecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Flush mocks base method.
func (m *MockTransaction) Flush(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Flush", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Flush indicates an expected call of Flush.
func (mr *MockTransactionMockRecorder) Flush(ctx any) *MockTransactionFlushCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Flush", reflect.TypeOf((*MockTransaction)(nil).Flush), ctx)
	return &MockTransactionFlushCall{Call: call}
}

// MockTransactionFlushCall wrap *gomock.Call
type MockTransactionFlushCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionFlushCall) Return(arg0 error) *MockTransactionFlushCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionFlushCall) Do(f func(context.Context) error) *MockTransactionFlushCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionFlushCall) DoAndReturn(f func(context.Context) error) *MockTransactionFlushCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HandleError mocks base method.
func (m *MockTransaction) HandleError(ctx context.Context, err error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HandleError", ctx, err)
	ret0, _ := ret[0].(error)
	return ret0
}

// HandleError indicates an expected call of HandleError.
func (mr *MockTransactionMockRecorder) HandleError(ctx, err any) *MockTransactionHandleErrorCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleError", reflect.TypeOf((*MockTransaction)(nil).HandleError), ctx, err)
	return &MockTransactionHandleErrorCall{Call: call}
}

// MockTransactionHandleErrorCall wrap *gomock.Call
type MockTransactionHandleErrorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionHandleErrorCall) Return(arg0 error) *MockTransactionHandleErrorCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionHandleErrorCall) Do(f func(context.Context, error) error) *MockTransactionHandleErrorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionHandleErrorCall) DoAndReturn(f func(context.Context, error) error) *MockTransactionHandleErrorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LastBlock mocks base method.
func (m *MockTransaction) LastBlock(ctx context.Context) (storage.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastBlock", ctx)
	ret0, _ := ret[0].(storage.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LastBlock indicates an expected call of LastBlock.
func (mr *MockTransactionMockRecorder) LastBlock(ctx any) *MockTransactionLastBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastBlock", reflect.TypeOf((*MockTransaction)(nil).LastBlock), ctx)
	return &MockTransactionLastBlockCall{Call: call}
}

// MockTransactionLastBlockCall wrap *gomock.Call
type MockTransactionLastBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionLastBlockCall) Return(block storage.Block, err error) *MockTransactionLastBlockCall {
	c.Call = c.Call.Return(block, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionLastBlockCall) Do(f func(context.Context) (storage.Block, error)) *MockTransactionLastBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionLastBlockCall) DoAndReturn(f func(context.Context) (storage.Block, error)) *MockTransactionLastBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Rollback mocks base method.
func (m *MockTransaction) Rollback(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockTransactionMockRecorder) Rollback(ctx any) *MockTransactionRollbackCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockTransaction)(nil).Rollback), ctx)
	return &MockTransactionRollbackCall{Call: call}
}

// MockTransactionRollbackCall wrap *gomock.Call
type MockTransactionRollbackCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackCall) Return(arg0 error) *MockTransactionRollbackCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackCall) Do(f func(context.Context) error) *MockTransactionRollbackCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackCall) DoAndReturn(f func(context.Context) error) *MockTransactionRollbackCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackAddresses mocks base method.
func (m *MockTransaction) RollbackAddresses(ctx context.Context, height types.Level) ([]storage.Address, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackAddresses", ctx, height)
	ret0, _ := ret[0].([]storage.Address)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RollbackAddresses indicates an expected call of RollbackAddresses.
func (mr *MockTransactionMockRecorder) RollbackAddresses(ctx, height any) *MockTransactionRollbackAddressesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackAddresses", reflect.TypeOf((*MockTransaction)(nil).RollbackAddresses), ctx, height)
	return &MockTransactionRollbackAddressesCall{Call: call}
}

// MockTransactionRollbackAddressesCall wrap *gomock.Call
type MockTransactionRollbackAddressesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackAddressesCall) Return(addresses []storage.Address, err error) *MockTransactionRollbackAddressesCall {
	c.Call = c.Call.Return(addresses, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackAddressesCall) Do(f func(context.Context, types.Level) ([]storage.Address, error)) *MockTransactionRollbackAddressesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackAddressesCall) DoAndReturn(f func(context.Context, types.Level) ([]storage.Address, error)) *MockTransactionRollbackAddressesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackBeaconWithdrawals mocks base method.
func (m *MockTransaction) RollbackBeaconWithdrawals(ctx context.Context, height types.Level) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackBeaconWithdrawals", ctx, height)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackBeaconWithdrawals indicates an expected call of RollbackBeaconWithdrawals.
func (mr *MockTransactionMockRecorder) RollbackBeaconWithdrawals(ctx, height any) *MockTransactionRollbackBeaconWithdrawalsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackBeaconWithdrawals", reflect.TypeOf((*MockTransaction)(nil).RollbackBeaconWithdrawals), ctx, height)
	return &MockTransactionRollbackBeaconWithdrawalsCall{Call: call}
}

// MockTransactionRollbackBeaconWithdrawalsCall wrap *gomock.Call
type MockTransactionRollbackBeaconWithdrawalsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackBeaconWithdrawalsCall) Return(arg0 error) *MockTransactionRollbackBeaconWithdrawalsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackBeaconWithdrawalsCall) Do(f func(context.Context, types.Level) error) *MockTransactionRollbackBeaconWithdrawalsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackBeaconWithdrawalsCall) DoAndReturn(f func(context.Context, types.Level) error) *MockTransactionRollbackBeaconWithdrawalsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackBlock mocks base method.
func (m *MockTransaction) RollbackBlock(ctx context.Context, height types.Level) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackBlock", ctx, height)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackBlock indicates an expected call of RollbackBlock.
func (mr *MockTransactionMockRecorder) RollbackBlock(ctx, height any) *MockTransactionRollbackBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackBlock", reflect.TypeOf((*MockTransaction)(nil).RollbackBlock), ctx, height)
	return &MockTransactionRollbackBlockCall{Call: call}
}

// MockTransactionRollbackBlockCall wrap *gomock.Call
type MockTransactionRollbackBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackBlockCall) Return(arg0 error) *MockTransactionRollbackBlockCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackBlockCall) Do(f func(context.Context, types.Level) error) *MockTransactionRollbackBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackBlockCall) DoAndReturn(f func(context.Context, types.Level) error) *MockTransactionRollbackBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackBlockStats mocks base method.
func (m *MockTransaction) RollbackBlockStats(ctx context.Context, height types.Level) (storage.BlockStats, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackBlockStats", ctx, height)
	ret0, _ := ret[0].(storage.BlockStats)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RollbackBlockStats indicates an expected call of RollbackBlockStats.
func (mr *MockTransactionMockRecorder) RollbackBlockStats(ctx, height any) *MockTransactionRollbackBlockStatsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackBlockStats", reflect.TypeOf((*MockTransaction)(nil).RollbackBlockStats), ctx, height)
	return &MockTransactionRollbackBlockStatsCall{Call: call}
}

// MockTransactionRollbackBlockStatsCall wrap *gomock.Call
type MockTransactionRollbackBlockStatsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackBlockStatsCall) Return(stats storage.BlockStats, err error) *MockTransactionRollbackBlockStatsCall {
	c.Call = c.Call.Return(stats, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackBlockStatsCall) Do(f func(context.Context, types.Level) (storage.BlockStats, error)) *MockTransactionRollbackBlockStatsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackBlockStatsCall) DoAndReturn(f func(context.Context, types.Level) (storage.BlockStats, error)) *MockTransactionRollbackBlockStatsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackContracts mocks base method.
func (m *MockTransaction) RollbackContracts(ctx context.Context, height types.Level) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackContracts", ctx, height)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackContracts indicates an expected call of RollbackContracts.
func (mr *MockTransactionMockRecorder) RollbackContracts(ctx, height any) *MockTransactionRollbackContractsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackContracts", reflect.TypeOf((*MockTransaction)(nil).RollbackContracts), ctx, height)
	return &MockTransactionRollbackContractsCall{Call: call}
}

// MockTransactionRollbackContractsCall wrap *gomock.Call
type MockTransactionRollbackContractsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackContractsCall) Return(arg0 error) *MockTransactionRollbackContractsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackContractsCall) Do(f func(context.Context, types.Level) error) *MockTransactionRollbackContractsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackContractsCall) DoAndReturn(f func(context.Context, types.Level) error) *MockTransactionRollbackContractsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackERC4337UserOps mocks base method.
func (m *MockTransaction) RollbackERC4337UserOps(ctx context.Context, height types.Level) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackERC4337UserOps", ctx, height)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackERC4337UserOps indicates an expected call of RollbackERC4337UserOps.
func (mr *MockTransactionMockRecorder) RollbackERC4337UserOps(ctx, height any) *MockTransactionRollbackERC4337UserOpsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackERC4337UserOps", reflect.TypeOf((*MockTransaction)(nil).RollbackERC4337UserOps), ctx, height)
	return &MockTransactionRollbackERC4337UserOpsCall{Call: call}
}

// MockTransactionRollbackERC4337UserOpsCall wrap *gomock.Call
type MockTransactionRollbackERC4337UserOpsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackERC4337UserOpsCall) Return(arg0 error) *MockTransactionRollbackERC4337UserOpsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackERC4337UserOpsCall) Do(f func(context.Context, types.Level) error) *MockTransactionRollbackERC4337UserOpsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackERC4337UserOpsCall) DoAndReturn(f func(context.Context, types.Level) error) *MockTransactionRollbackERC4337UserOpsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackLogs mocks base method.
func (m *MockTransaction) RollbackLogs(ctx context.Context, height types.Level) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackLogs", ctx, height)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackLogs indicates an expected call of RollbackLogs.
func (mr *MockTransactionMockRecorder) RollbackLogs(ctx, height any) *MockTransactionRollbackLogsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackLogs", reflect.TypeOf((*MockTransaction)(nil).RollbackLogs), ctx, height)
	return &MockTransactionRollbackLogsCall{Call: call}
}

// MockTransactionRollbackLogsCall wrap *gomock.Call
type MockTransactionRollbackLogsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackLogsCall) Return(arg0 error) *MockTransactionRollbackLogsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackLogsCall) Do(f func(context.Context, types.Level) error) *MockTransactionRollbackLogsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackLogsCall) DoAndReturn(f func(context.Context, types.Level) error) *MockTransactionRollbackLogsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackTokens mocks base method.
func (m *MockTransaction) RollbackTokens(ctx context.Context, height types.Level) ([]storage.Token, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackTokens", ctx, height)
	ret0, _ := ret[0].([]storage.Token)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RollbackTokens indicates an expected call of RollbackTokens.
func (mr *MockTransactionMockRecorder) RollbackTokens(ctx, height any) *MockTransactionRollbackTokensCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackTokens", reflect.TypeOf((*MockTransaction)(nil).RollbackTokens), ctx, height)
	return &MockTransactionRollbackTokensCall{Call: call}
}

// MockTransactionRollbackTokensCall wrap *gomock.Call
type MockTransactionRollbackTokensCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackTokensCall) Return(tokens []storage.Token, err error) *MockTransactionRollbackTokensCall {
	c.Call = c.Call.Return(tokens, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackTokensCall) Do(f func(context.Context, types.Level) ([]storage.Token, error)) *MockTransactionRollbackTokensCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackTokensCall) DoAndReturn(f func(context.Context, types.Level) ([]storage.Token, error)) *MockTransactionRollbackTokensCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackTraces mocks base method.
func (m *MockTransaction) RollbackTraces(ctx context.Context, height types.Level) ([]storage.Trace, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackTraces", ctx, height)
	ret0, _ := ret[0].([]storage.Trace)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RollbackTraces indicates an expected call of RollbackTraces.
func (mr *MockTransactionMockRecorder) RollbackTraces(ctx, height any) *MockTransactionRollbackTracesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackTraces", reflect.TypeOf((*MockTransaction)(nil).RollbackTraces), ctx, height)
	return &MockTransactionRollbackTracesCall{Call: call}
}

// MockTransactionRollbackTracesCall wrap *gomock.Call
type MockTransactionRollbackTracesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackTracesCall) Return(traces []storage.Trace, err error) *MockTransactionRollbackTracesCall {
	c.Call = c.Call.Return(traces, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackTracesCall) Do(f func(context.Context, types.Level) ([]storage.Trace, error)) *MockTransactionRollbackTracesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackTracesCall) DoAndReturn(f func(context.Context, types.Level) ([]storage.Trace, error)) *MockTransactionRollbackTracesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackTransfers mocks base method.
func (m *MockTransaction) RollbackTransfers(ctx context.Context, height types.Level) ([]storage.Transfer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackTransfers", ctx, height)
	ret0, _ := ret[0].([]storage.Transfer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RollbackTransfers indicates an expected call of RollbackTransfers.
func (mr *MockTransactionMockRecorder) RollbackTransfers(ctx, height any) *MockTransactionRollbackTransfersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackTransfers", reflect.TypeOf((*MockTransaction)(nil).RollbackTransfers), ctx, height)
	return &MockTransactionRollbackTransfersCall{Call: call}
}

// MockTransactionRollbackTransfersCall wrap *gomock.Call
type MockTransactionRollbackTransfersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackTransfersCall) Return(transfers []storage.Transfer, err error) *MockTransactionRollbackTransfersCall {
	c.Call = c.Call.Return(transfers, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackTransfersCall) Do(f func(context.Context, types.Level) ([]storage.Transfer, error)) *MockTransactionRollbackTransfersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackTransfersCall) DoAndReturn(f func(context.Context, types.Level) ([]storage.Transfer, error)) *MockTransactionRollbackTransfersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackTxs mocks base method.
func (m *MockTransaction) RollbackTxs(ctx context.Context, height types.Level) ([]storage.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackTxs", ctx, height)
	ret0, _ := ret[0].([]storage.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RollbackTxs indicates an expected call of RollbackTxs.
func (mr *MockTransactionMockRecorder) RollbackTxs(ctx, height any) *MockTransactionRollbackTxsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackTxs", reflect.TypeOf((*MockTransaction)(nil).RollbackTxs), ctx, height)
	return &MockTransactionRollbackTxsCall{Call: call}
}

// MockTransactionRollbackTxsCall wrap *gomock.Call
type MockTransactionRollbackTxsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackTxsCall) Return(txs []storage.Tx, err error) *MockTransactionRollbackTxsCall {
	c.Call = c.Call.Return(txs, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackTxsCall) Do(f func(context.Context, types.Level) ([]storage.Tx, error)) *MockTransactionRollbackTxsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackTxsCall) DoAndReturn(f func(context.Context, types.Level) ([]storage.Tx, error)) *MockTransactionRollbackTxsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveAddresses mocks base method.
func (m *MockTransaction) SaveAddresses(ctx context.Context, addresses ...*storage.Address) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range addresses {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveAddresses", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaveAddresses indicates an expected call of SaveAddresses.
func (mr *MockTransactionMockRecorder) SaveAddresses(ctx any, addresses ...any) *MockTransactionSaveAddressesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, addresses...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveAddresses", reflect.TypeOf((*MockTransaction)(nil).SaveAddresses), varargs...)
	return &MockTransactionSaveAddressesCall{Call: call}
}

// MockTransactionSaveAddressesCall wrap *gomock.Call
type MockTransactionSaveAddressesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveAddressesCall) Return(arg0 int64, arg1 error) *MockTransactionSaveAddressesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveAddressesCall) Do(f func(context.Context, ...*storage.Address) (int64, error)) *MockTransactionSaveAddressesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveAddressesCall) DoAndReturn(f func(context.Context, ...*storage.Address) (int64, error)) *MockTransactionSaveAddressesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveBalances mocks base method.
func (m *MockTransaction) SaveBalances(ctx context.Context, balances ...*storage.Balance) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range balances {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveBalances", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveBalances indicates an expected call of SaveBalances.
func (mr *MockTransactionMockRecorder) SaveBalances(ctx any, balances ...any) *MockTransactionSaveBalancesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, balances...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveBalances", reflect.TypeOf((*MockTransaction)(nil).SaveBalances), varargs...)
	return &MockTransactionSaveBalancesCall{Call: call}
}

// MockTransactionSaveBalancesCall wrap *gomock.Call
type MockTransactionSaveBalancesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveBalancesCall) Return(arg0 error) *MockTransactionSaveBalancesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveBalancesCall) Do(f func(context.Context, ...*storage.Balance) error) *MockTransactionSaveBalancesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveBalancesCall) DoAndReturn(f func(context.Context, ...*storage.Balance) error) *MockTransactionSaveBalancesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveBeaconWithdrawals mocks base method.
func (m *MockTransaction) SaveBeaconWithdrawals(ctx context.Context, withdrawals ...*storage.BeaconWithdrawal) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range withdrawals {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveBeaconWithdrawals", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveBeaconWithdrawals indicates an expected call of SaveBeaconWithdrawals.
func (mr *MockTransactionMockRecorder) SaveBeaconWithdrawals(ctx any, withdrawals ...any) *MockTransactionSaveBeaconWithdrawalsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, withdrawals...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveBeaconWithdrawals", reflect.TypeOf((*MockTransaction)(nil).SaveBeaconWithdrawals), varargs...)
	return &MockTransactionSaveBeaconWithdrawalsCall{Call: call}
}

// MockTransactionSaveBeaconWithdrawalsCall wrap *gomock.Call
type MockTransactionSaveBeaconWithdrawalsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveBeaconWithdrawalsCall) Return(arg0 error) *MockTransactionSaveBeaconWithdrawalsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveBeaconWithdrawalsCall) Do(f func(context.Context, ...*storage.BeaconWithdrawal) error) *MockTransactionSaveBeaconWithdrawalsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveBeaconWithdrawalsCall) DoAndReturn(f func(context.Context, ...*storage.BeaconWithdrawal) error) *MockTransactionSaveBeaconWithdrawalsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveContracts mocks base method.
func (m *MockTransaction) SaveContracts(ctx context.Context, addresses ...*storage.Contract) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range addresses {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveContracts", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaveContracts indicates an expected call of SaveContracts.
func (mr *MockTransactionMockRecorder) SaveContracts(ctx any, addresses ...any) *MockTransactionSaveContractsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, addresses...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveContracts", reflect.TypeOf((*MockTransaction)(nil).SaveContracts), varargs...)
	return &MockTransactionSaveContractsCall{Call: call}
}

// MockTransactionSaveContractsCall wrap *gomock.Call
type MockTransactionSaveContractsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveContractsCall) Return(arg0 int64, arg1 error) *MockTransactionSaveContractsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveContractsCall) Do(f func(context.Context, ...*storage.Contract) (int64, error)) *MockTransactionSaveContractsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveContractsCall) DoAndReturn(f func(context.Context, ...*storage.Contract) (int64, error)) *MockTransactionSaveContractsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveERC4337UserOps mocks base method.
func (m *MockTransaction) SaveERC4337UserOps(ctx context.Context, userOps ...*storage.ERC4337UserOp) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range userOps {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveERC4337UserOps", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveERC4337UserOps indicates an expected call of SaveERC4337UserOps.
func (mr *MockTransactionMockRecorder) SaveERC4337UserOps(ctx any, userOps ...any) *MockTransactionSaveERC4337UserOpsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, userOps...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveERC4337UserOps", reflect.TypeOf((*MockTransaction)(nil).SaveERC4337UserOps), varargs...)
	return &MockTransactionSaveERC4337UserOpsCall{Call: call}
}

// MockTransactionSaveERC4337UserOpsCall wrap *gomock.Call
type MockTransactionSaveERC4337UserOpsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveERC4337UserOpsCall) Return(arg0 error) *MockTransactionSaveERC4337UserOpsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveERC4337UserOpsCall) Do(f func(context.Context, ...*storage.ERC4337UserOp) error) *MockTransactionSaveERC4337UserOpsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveERC4337UserOpsCall) DoAndReturn(f func(context.Context, ...*storage.ERC4337UserOp) error) *MockTransactionSaveERC4337UserOpsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveLogs mocks base method.
func (m *MockTransaction) SaveLogs(ctx context.Context, logs ...*storage.Log) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range logs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveLogs", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveLogs indicates an expected call of SaveLogs.
func (mr *MockTransactionMockRecorder) SaveLogs(ctx any, logs ...any) *MockTransactionSaveLogsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, logs...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveLogs", reflect.TypeOf((*MockTransaction)(nil).SaveLogs), varargs...)
	return &MockTransactionSaveLogsCall{Call: call}
}

// MockTransactionSaveLogsCall wrap *gomock.Call
type MockTransactionSaveLogsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveLogsCall) Return(arg0 error) *MockTransactionSaveLogsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveLogsCall) Do(f func(context.Context, ...*storage.Log) error) *MockTransactionSaveLogsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveLogsCall) DoAndReturn(f func(context.Context, ...*storage.Log) error) *MockTransactionSaveLogsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveProxyContracts mocks base method.
func (m *MockTransaction) SaveProxyContracts(ctx context.Context, contracts ...*storage.ProxyContract) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range contracts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveProxyContracts", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveProxyContracts indicates an expected call of SaveProxyContracts.
func (mr *MockTransactionMockRecorder) SaveProxyContracts(ctx any, contracts ...any) *MockTransactionSaveProxyContractsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, contracts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveProxyContracts", reflect.TypeOf((*MockTransaction)(nil).SaveProxyContracts), varargs...)
	return &MockTransactionSaveProxyContractsCall{Call: call}
}

// MockTransactionSaveProxyContractsCall wrap *gomock.Call
type MockTransactionSaveProxyContractsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveProxyContractsCall) Return(arg0 error) *MockTransactionSaveProxyContractsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveProxyContractsCall) Do(f func(context.Context, ...*storage.ProxyContract) error) *MockTransactionSaveProxyContractsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveProxyContractsCall) DoAndReturn(f func(context.Context, ...*storage.ProxyContract) error) *MockTransactionSaveProxyContractsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveSources mocks base method.
func (m *MockTransaction) SaveSources(ctx context.Context, sources ...*storage.Source) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range sources {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveSources", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveSources indicates an expected call of SaveSources.
func (mr *MockTransactionMockRecorder) SaveSources(ctx any, sources ...any) *MockTransactionSaveSourcesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, sources...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveSources", reflect.TypeOf((*MockTransaction)(nil).SaveSources), varargs...)
	return &MockTransactionSaveSourcesCall{Call: call}
}

// MockTransactionSaveSourcesCall wrap *gomock.Call
type MockTransactionSaveSourcesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveSourcesCall) Return(arg0 error) *MockTransactionSaveSourcesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveSourcesCall) Do(f func(context.Context, ...*storage.Source) error) *MockTransactionSaveSourcesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveSourcesCall) DoAndReturn(f func(context.Context, ...*storage.Source) error) *MockTransactionSaveSourcesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveTokenBalances mocks base method.
func (m *MockTransaction) SaveTokenBalances(ctx context.Context, tokenBalances ...*storage.TokenBalance) ([]storage.TokenBalance, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range tokenBalances {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveTokenBalances", varargs...)
	ret0, _ := ret[0].([]storage.TokenBalance)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaveTokenBalances indicates an expected call of SaveTokenBalances.
func (mr *MockTransactionMockRecorder) SaveTokenBalances(ctx any, tokenBalances ...any) *MockTransactionSaveTokenBalancesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, tokenBalances...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveTokenBalances", reflect.TypeOf((*MockTransaction)(nil).SaveTokenBalances), varargs...)
	return &MockTransactionSaveTokenBalancesCall{Call: call}
}

// MockTransactionSaveTokenBalancesCall wrap *gomock.Call
type MockTransactionSaveTokenBalancesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveTokenBalancesCall) Return(tb []storage.TokenBalance, err error) *MockTransactionSaveTokenBalancesCall {
	c.Call = c.Call.Return(tb, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveTokenBalancesCall) Do(f func(context.Context, ...*storage.TokenBalance) ([]storage.TokenBalance, error)) *MockTransactionSaveTokenBalancesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveTokenBalancesCall) DoAndReturn(f func(context.Context, ...*storage.TokenBalance) ([]storage.TokenBalance, error)) *MockTransactionSaveTokenBalancesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveTokenMetadata mocks base method.
func (m *MockTransaction) SaveTokenMetadata(ctx context.Context, tokens ...*storage.Token) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range tokens {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveTokenMetadata", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveTokenMetadata indicates an expected call of SaveTokenMetadata.
func (mr *MockTransactionMockRecorder) SaveTokenMetadata(ctx any, tokens ...any) *MockTransactionSaveTokenMetadataCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, tokens...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveTokenMetadata", reflect.TypeOf((*MockTransaction)(nil).SaveTokenMetadata), varargs...)
	return &MockTransactionSaveTokenMetadataCall{Call: call}
}

// MockTransactionSaveTokenMetadataCall wrap *gomock.Call
type MockTransactionSaveTokenMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveTokenMetadataCall) Return(arg0 error) *MockTransactionSaveTokenMetadataCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveTokenMetadataCall) Do(f func(context.Context, ...*storage.Token) error) *MockTransactionSaveTokenMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveTokenMetadataCall) DoAndReturn(f func(context.Context, ...*storage.Token) error) *MockTransactionSaveTokenMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveTokens mocks base method.
func (m *MockTransaction) SaveTokens(ctx context.Context, tokens ...*storage.Token) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range tokens {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveTokens", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SaveTokens indicates an expected call of SaveTokens.
func (mr *MockTransactionMockRecorder) SaveTokens(ctx any, tokens ...any) *MockTransactionSaveTokensCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, tokens...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveTokens", reflect.TypeOf((*MockTransaction)(nil).SaveTokens), varargs...)
	return &MockTransactionSaveTokensCall{Call: call}
}

// MockTransactionSaveTokensCall wrap *gomock.Call
type MockTransactionSaveTokensCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveTokensCall) Return(arg0 int64, arg1 error) *MockTransactionSaveTokensCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveTokensCall) Do(f func(context.Context, ...*storage.Token) (int64, error)) *MockTransactionSaveTokensCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveTokensCall) DoAndReturn(f func(context.Context, ...*storage.Token) (int64, error)) *MockTransactionSaveTokensCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveTraces mocks base method.
func (m *MockTransaction) SaveTraces(ctx context.Context, traces ...*storage.Trace) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range traces {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveTraces", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveTraces indicates an expected call of SaveTraces.
func (mr *MockTransactionMockRecorder) SaveTraces(ctx any, traces ...any) *MockTransactionSaveTracesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, traces...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveTraces", reflect.TypeOf((*MockTransaction)(nil).SaveTraces), varargs...)
	return &MockTransactionSaveTracesCall{Call: call}
}

// MockTransactionSaveTracesCall wrap *gomock.Call
type MockTransactionSaveTracesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveTracesCall) Return(arg0 error) *MockTransactionSaveTracesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveTracesCall) Do(f func(context.Context, ...*storage.Trace) error) *MockTransactionSaveTracesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveTracesCall) DoAndReturn(f func(context.Context, ...*storage.Trace) error) *MockTransactionSaveTracesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveTransactions mocks base method.
func (m *MockTransaction) SaveTransactions(ctx context.Context, txs ...*storage.Tx) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range txs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveTransactions", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveTransactions indicates an expected call of SaveTransactions.
func (mr *MockTransactionMockRecorder) SaveTransactions(ctx any, txs ...any) *MockTransactionSaveTransactionsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, txs...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveTransactions", reflect.TypeOf((*MockTransaction)(nil).SaveTransactions), varargs...)
	return &MockTransactionSaveTransactionsCall{Call: call}
}

// MockTransactionSaveTransactionsCall wrap *gomock.Call
type MockTransactionSaveTransactionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveTransactionsCall) Return(arg0 error) *MockTransactionSaveTransactionsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveTransactionsCall) Do(f func(context.Context, ...*storage.Tx) error) *MockTransactionSaveTransactionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveTransactionsCall) DoAndReturn(f func(context.Context, ...*storage.Tx) error) *MockTransactionSaveTransactionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveTransfers mocks base method.
func (m *MockTransaction) SaveTransfers(ctx context.Context, transfers ...*storage.Transfer) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range transfers {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SaveTransfers", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveTransfers indicates an expected call of SaveTransfers.
func (mr *MockTransactionMockRecorder) SaveTransfers(ctx any, transfers ...any) *MockTransactionSaveTransfersCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, transfers...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveTransfers", reflect.TypeOf((*MockTransaction)(nil).SaveTransfers), varargs...)
	return &MockTransactionSaveTransfersCall{Call: call}
}

// MockTransactionSaveTransfersCall wrap *gomock.Call
type MockTransactionSaveTransfersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionSaveTransfersCall) Return(arg0 error) *MockTransactionSaveTransfersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionSaveTransfersCall) Do(f func(context.Context, ...*storage.Transfer) error) *MockTransactionSaveTransfersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionSaveTransfersCall) DoAndReturn(f func(context.Context, ...*storage.Transfer) error) *MockTransactionSaveTransfersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// State mocks base method.
func (m *MockTransaction) State(ctx context.Context, name string) (storage.State, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "State", ctx, name)
	ret0, _ := ret[0].(storage.State)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// State indicates an expected call of State.
func (mr *MockTransactionMockRecorder) State(ctx, name any) *MockTransactionStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "State", reflect.TypeOf((*MockTransaction)(nil).State), ctx, name)
	return &MockTransactionStateCall{Call: call}
}

// MockTransactionStateCall wrap *gomock.Call
type MockTransactionStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionStateCall) Return(state storage.State, err error) *MockTransactionStateCall {
	c.Call = c.Call.Return(state, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionStateCall) Do(f func(context.Context, string) (storage.State, error)) *MockTransactionStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionStateCall) DoAndReturn(f func(context.Context, string) (storage.State, error)) *MockTransactionStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Tx mocks base method.
func (m *MockTransaction) Tx() *bun.Tx {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tx")
	ret0, _ := ret[0].(*bun.Tx)
	return ret0
}

// Tx indicates an expected call of Tx.
func (mr *MockTransactionMockRecorder) Tx() *MockTransactionTxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tx", reflect.TypeOf((*MockTransaction)(nil).Tx))
	return &MockTransactionTxCall{Call: call}
}

// MockTransactionTxCall wrap *gomock.Call
type MockTransactionTxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionTxCall) Return(arg0 *bun.Tx) *MockTransactionTxCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionTxCall) Do(f func() *bun.Tx) *MockTransactionTxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionTxCall) DoAndReturn(f func() *bun.Tx) *MockTransactionTxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Update mocks base method.
func (m *MockTransaction) Update(ctx context.Context, model any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, model)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockTransactionMockRecorder) Update(ctx, model any) *MockTransactionUpdateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTransaction)(nil).Update), ctx, model)
	return &MockTransactionUpdateCall{Call: call}
}

// MockTransactionUpdateCall wrap *gomock.Call
type MockTransactionUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionUpdateCall) Return(arg0 error) *MockTransactionUpdateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionUpdateCall) Do(f func(context.Context, any) error) *MockTransactionUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionUpdateCall) DoAndReturn(f func(context.Context, any) error) *MockTransactionUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockNotificator is a mock of Notificator interface.
type MockNotificator struct {
	ctrl     *gomock.Controller
	recorder *MockNotificatorMockRecorder
	isgomock struct{}
}

// MockNotificatorMockRecorder is the mock recorder for MockNotificator.
type MockNotificatorMockRecorder struct {
	mock *MockNotificator
}

// NewMockNotificator creates a new mock instance.
func NewMockNotificator(ctrl *gomock.Controller) *MockNotificator {
	mock := &MockNotificator{ctrl: ctrl}
	mock.recorder = &MockNotificatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificator) EXPECT() *MockNotificatorMockRecorder {
	return m.recorder
}

// Notify mocks base method.
func (m *MockNotificator) Notify(ctx context.Context, channel, payload string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Notify", ctx, channel, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// Notify indicates an expected call of Notify.
func (mr *MockNotificatorMockRecorder) Notify(ctx, channel, payload any) *MockNotificatorNotifyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Notify", reflect.TypeOf((*MockNotificator)(nil).Notify), ctx, channel, payload)
	return &MockNotificatorNotifyCall{Call: call}
}

// MockNotificatorNotifyCall wrap *gomock.Call
type MockNotificatorNotifyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotificatorNotifyCall) Return(arg0 error) *MockNotificatorNotifyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotificatorNotifyCall) Do(f func(context.Context, string, string) error) *MockNotificatorNotifyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotificatorNotifyCall) DoAndReturn(f func(context.Context, string, string) error) *MockNotificatorNotifyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockListener is a mock of Listener interface.
type MockListener struct {
	ctrl     *gomock.Controller
	recorder *MockListenerMockRecorder
	isgomock struct{}
}

// MockListenerMockRecorder is the mock recorder for MockListener.
type MockListenerMockRecorder struct {
	mock *MockListener
}

// NewMockListener creates a new mock instance.
func NewMockListener(ctrl *gomock.Controller) *MockListener {
	mock := &MockListener{ctrl: ctrl}
	mock.recorder = &MockListenerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListener) EXPECT() *MockListenerMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockListener) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockListenerMockRecorder) Close() *MockListenerCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockListener)(nil).Close))
	return &MockListenerCloseCall{Call: call}
}

// MockListenerCloseCall wrap *gomock.Call
type MockListenerCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockListenerCloseCall) Return(arg0 error) *MockListenerCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockListenerCloseCall) Do(f func() error) *MockListenerCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockListenerCloseCall) DoAndReturn(f func() error) *MockListenerCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Listen mocks base method.
func (m *MockListener) Listen() chan *pq.Notification {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Listen")
	ret0, _ := ret[0].(chan *pq.Notification)
	return ret0
}

// Listen indicates an expected call of Listen.
func (mr *MockListenerMockRecorder) Listen() *MockListenerListenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Listen", reflect.TypeOf((*MockListener)(nil).Listen))
	return &MockListenerListenCall{Call: call}
}

// MockListenerListenCall wrap *gomock.Call
type MockListenerListenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockListenerListenCall) Return(arg0 chan *pq.Notification) *MockListenerListenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockListenerListenCall) Do(f func() chan *pq.Notification) *MockListenerListenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockListenerListenCall) DoAndReturn(f func() chan *pq.Notification) *MockListenerListenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Subscribe mocks base method.
func (m *MockListener) Subscribe(ctx context.Context, channels ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range channels {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockListenerMockRecorder) Subscribe(ctx any, channels ...any) *MockListenerSubscribeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, channels...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockListener)(nil).Subscribe), varargs...)
	return &MockListenerSubscribeCall{Call: call}
}

// MockListenerSubscribeCall wrap *gomock.Call
type MockListenerSubscribeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockListenerSubscribeCall) Return(arg0 error) *MockListenerSubscribeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockListenerSubscribeCall) Do(f func(context.Context, ...string) error) *MockListenerSubscribeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockListenerSubscribeCall) DoAndReturn(f func(context.Context, ...string) error) *MockListenerSubscribeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockListenerFactory is a mock of ListenerFactory interface.
type MockListenerFactory struct {
	ctrl     *gomock.Controller
	recorder *MockListenerFactoryMockRecorder
	isgomock struct{}
}

// MockListenerFactoryMockRecorder is the mock recorder for MockListenerFactory.
type MockListenerFactoryMockRecorder struct {
	mock *MockListenerFactory
}

// NewMockListenerFactory creates a new mock instance.
func NewMockListenerFactory(ctrl *gomock.Controller) *MockListenerFactory {
	mock := &MockListenerFactory{ctrl: ctrl}
	mock.recorder = &MockListenerFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockListenerFactory) EXPECT() *MockListenerFactoryMockRecorder {
	return m.recorder
}

// CreateListener mocks base method.
func (m *MockListenerFactory) CreateListener() storage.Listener {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateListener")
	ret0, _ := ret[0].(storage.Listener)
	return ret0
}

// CreateListener indicates an expected call of CreateListener.
func (mr *MockListenerFactoryMockRecorder) CreateListener() *MockListenerFactoryCreateListenerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateListener", reflect.TypeOf((*MockListenerFactory)(nil).CreateListener))
	return &MockListenerFactoryCreateListenerCall{Call: call}
}

// MockListenerFactoryCreateListenerCall wrap *gomock.Call
type MockListenerFactoryCreateListenerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockListenerFactoryCreateListenerCall) Return(arg0 storage.Listener) *MockListenerFactoryCreateListenerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockListenerFactoryCreateListenerCall) Do(f func() storage.Listener) *MockListenerFactoryCreateListenerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockListenerFactoryCreateListenerCall) DoAndReturn(f func() storage.Listener) *MockListenerFactoryCreateListenerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockISearch is a mock of ISearch interface.
type MockISearch struct {
	ctrl     *gomock.Controller
	recorder *MockISearchMockRecorder
	isgomock struct{}
}

// MockISearchMockRecorder is the mock recorder for MockISearch.
type MockISearchMockRecorder struct {
	mock *MockISearch
}

// NewMockISearch creates a new mock instance.
func NewMockISearch(ctrl *gomock.Controller) *MockISearch {
	mock := &MockISearch{ctrl: ctrl}
	mock.recorder = &MockISearchMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockISearch) EXPECT() *MockISearchMockRecorder {
	return m.recorder
}

// Search mocks base method.
func (m *MockISearch) Search(ctx context.Context, query []byte, limit, offset int) ([]storage.SearchResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Search", ctx, query, limit, offset)
	ret0, _ := ret[0].([]storage.SearchResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Search indicates an expected call of Search.
func (mr *MockISearchMockRecorder) Search(ctx, query, limit, offset any) *MockISearchSearchCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Search", reflect.TypeOf((*MockISearch)(nil).Search), ctx, query, limit, offset)
	return &MockISearchSearchCall{Call: call}
}

// MockISearchSearchCall wrap *gomock.Call
type MockISearchSearchCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockISearchSearchCall) Return(arg0 []storage.SearchResult, arg1 error) *MockISearchSearchCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockISearchSearchCall) Do(f func(context.Context, []byte, int, int) ([]storage.SearchResult, error)) *MockISearchSearchCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockISearchSearchCall) DoAndReturn(f func(context.Context, []byte, int, int) ([]storage.SearchResult, error)) *MockISearchSearchCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SearchText mocks base method.
func (m *MockISearch) SearchText(ctx context.Context, text string, limit, offset int) ([]storage.SearchResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchText", ctx, text, limit, offset)
	ret0, _ := ret[0].([]storage.SearchResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchText indicates an expected call of SearchText.
func (mr *MockISearchMockRecorder) SearchText(ctx, text, limit, offset any) *MockISearchSearchTextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchText", reflect.TypeOf((*MockISearch)(nil).SearchText), ctx, text, limit, offset)
	return &MockISearchSearchTextCall{Call: call}
}

// MockISearchSearchTextCall wrap *gomock.Call
type MockISearchSearchTextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockISearchSearchTextCall) Return(arg0 []storage.SearchResult, arg1 error) *MockISearchSearchTextCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockISearchSearchTextCall) Do(f func(context.Context, string, int, int) ([]storage.SearchResult, error)) *MockISearchSearchTextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockISearchSearchTextCall) DoAndReturn(f func(context.Context, string, int, int) ([]storage.SearchResult, error)) *MockISearchSearchTextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
