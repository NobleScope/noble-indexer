// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package types

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"strings"
)

const (
	// None is a LicenseType of type none.
	None LicenseType = "none"
	// Unlicense is a LicenseType of type unlicense.
	Unlicense LicenseType = "unlicense"
	// Mit is a LicenseType of type mit.
	Mit LicenseType = "mit"
	// GnuGplV2 is a LicenseType of type gnu_gpl_v2.
	GnuGplV2 LicenseType = "gnu_gpl_v2"
	// GnuGplV3 is a LicenseType of type gnu_gpl_v3.
	GnuGplV3 LicenseType = "gnu_gpl_v3"
	// GnuLgplV21 is a LicenseType of type gnu_lgpl_v2_1.
	GnuLgplV21 LicenseType = "gnu_lgpl_v2_1"
	// GnuLgplV3 is a LicenseType of type gnu_lgpl_v3.
	GnuLgplV3 LicenseType = "gnu_lgpl_v3"
	// Bsd2Clause is a LicenseType of type bsd_2_clause.
	Bsd2Clause LicenseType = "bsd_2_clause"
	// Bsd3Clause is a LicenseType of type bsd_3_clause.
	Bsd3Clause LicenseType = "bsd_3_clause"
	// Mpl20 is a LicenseType of type mpl_2_0.
	Mpl20 LicenseType = "mpl_2_0"
	// Osl30 is a LicenseType of type osl_3_0.
	Osl30 LicenseType = "osl_3_0"
	// Apache20 is a LicenseType of type apache_2_0.
	Apache20 LicenseType = "apache_2_0"
	// GnuAgplV3 is a LicenseType of type gnu_agpl_v3.
	GnuAgplV3 LicenseType = "gnu_agpl_v3"
	// Bsl11 is a LicenseType of type bsl_1_1.
	Bsl11 LicenseType = "bsl_1_1"
)

var ErrInvalidLicenseType = fmt.Errorf("not a valid LicenseType, try [%s]", strings.Join(_LicenseTypeNames, ", "))

var _LicenseTypeNames = []string{
	string(None),
	string(Unlicense),
	string(Mit),
	string(GnuGplV2),
	string(GnuGplV3),
	string(GnuLgplV21),
	string(GnuLgplV3),
	string(Bsd2Clause),
	string(Bsd3Clause),
	string(Mpl20),
	string(Osl30),
	string(Apache20),
	string(GnuAgplV3),
	string(Bsl11),
}

// LicenseTypeNames returns a list of possible string values of LicenseType.
func LicenseTypeNames() []string {
	tmp := make([]string, len(_LicenseTypeNames))
	copy(tmp, _LicenseTypeNames)
	return tmp
}

// LicenseTypeValues returns a list of the values for LicenseType
func LicenseTypeValues() []LicenseType {
	return []LicenseType{
		None,
		Unlicense,
		Mit,
		GnuGplV2,
		GnuGplV3,
		GnuLgplV21,
		GnuLgplV3,
		Bsd2Clause,
		Bsd3Clause,
		Mpl20,
		Osl30,
		Apache20,
		GnuAgplV3,
		Bsl11,
	}
}

// String implements the Stringer interface.
func (x LicenseType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LicenseType) IsValid() bool {
	_, err := ParseLicenseType(string(x))
	return err == nil
}

var _LicenseTypeValue = map[string]LicenseType{
	"none":          None,
	"unlicense":     Unlicense,
	"mit":           Mit,
	"gnu_gpl_v2":    GnuGplV2,
	"gnu_gpl_v3":    GnuGplV3,
	"gnu_lgpl_v2_1": GnuLgplV21,
	"gnu_lgpl_v3":   GnuLgplV3,
	"bsd_2_clause":  Bsd2Clause,
	"bsd_3_clause":  Bsd3Clause,
	"mpl_2_0":       Mpl20,
	"osl_3_0":       Osl30,
	"apache_2_0":    Apache20,
	"gnu_agpl_v3":   GnuAgplV3,
	"bsl_1_1":       Bsl11,
}

// ParseLicenseType attempts to convert a string to a LicenseType.
func ParseLicenseType(name string) (LicenseType, error) {
	if x, ok := _LicenseTypeValue[name]; ok {
		return x, nil
	}
	return LicenseType(""), fmt.Errorf("%s is %w", name, ErrInvalidLicenseType)
}

// MarshalText implements the text marshaller method.
func (x LicenseType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *LicenseType) UnmarshalText(text []byte) error {
	tmp, err := ParseLicenseType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errLicenseTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *LicenseType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = LicenseType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseLicenseType(v)
	case []byte:
		*x, err = ParseLicenseType(string(v))
	case LicenseType:
		*x = v
	case *LicenseType:
		if v == nil {
			return errLicenseTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errLicenseTypeNilPtr
		}
		*x, err = ParseLicenseType(*v)
	default:
		return errors.New("invalid type for LicenseType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x LicenseType) Value() (driver.Value, error) {
	return x.String(), nil
}
